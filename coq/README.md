# Coq Formalization of Netter Optimizations

## Dependencies

- Coq (This has been tested with 8.13)

- The following OPAM packages:
  
  + `coq-mathcomp-ssreflect` (tested with 1.12)
  + `coq-mathcomp-fingroup` (tested with 1.12)
  + `coq-mathcomp-algebra` (tested with 1.12)
  + `coq-deriving` (tested with 0.1.0)
  + `coq-extructures` (tested with 0.3.1)
  
## Compiling

Just hit `make`

## Contents

- `Extra.v`: addenda to mathcomp and extructures

- `Prob.v`: theory of finite probability distributions

- `Expr.v`: arithmetic, boolean and rational expressions

- `Imp.v`: the bulk of the development.  This files defines the syntax of Imp
  commands, their semantics, and the inlining and dead-store elimination
  passes.  The main definitions are:
   
  + `live_vars defs c vs`: Compute which variables are needed to compute the
    values of the variables `v \in vs` in the final state of the program.
    (Correctness lemma: `live_varsP`).
    
  + `dead_store_elim defs c vs`: Returns a command `c'` that erases stores that
    are not needed to compute the variables in `vs`. (Correctness lemma:
    `dead_store_elimP`.)
    
  + `dead_store_elim_opt`: An optimized version of `dead_store_elim` that avoids
    redundant dependency computations. (Correctness proof:
    `dead_store_elim_optE`.)
    
  + `inline c rew`: Produces a pair `(c', rew')` of a command `c'` and a reward
    `rew'` that have the same semantics as the inputs of the function.  The
    commands are produced by propagating as many deterministic assignments as
    possible. (Correctness proofs: `inline_run` and `inline_rew`.)
    
## Main Differences with Respect to the Haskell Implementation

- In Haskell, arithmetic and logical operations are merged into a single type of
  expressions. (cf. `src/Netter/Prism/Expr.hs`).
  
- The syntax of Imp commands in Haskell (`src/Netter/Imp.hs`) groups
  instructions and commands into separate types, whereas in the Coq development
  they are merged into a single type `com`.

- Assignments in Haskell can be of the form 

        X := c1 -> p1 : e1 + ... + pn : en
             
             ...
             ck -> q1 : f1 + ... + qm : fm
             
  where each `c1` is a boolean guard determining when the assignment can take
  place, and each expression `p1 : e1 + ... + pn : en` is a probability
  distribution over possible assignment expressions.  This allows us to take
  advantage of guards in PRISM models to flatten more if statements.  In Coq,
  only a single non-guarded probabilistic expression can be assigned.

- In Coq, variables are not bounded: they can take any integer as their values.

- The Haskell `inline` function (cf. `src/Netter/Compiler/Optimize.hs`) allows
  the user to prevent the inlining of variables that can receive probabilistic
  samples.  The Coq code does not provide this option.
  
- To keep the models smaller, the Haskell code lifts the RHS of assignments to
  separate formulas, and inlines the formulas instead of the RHSs.  In PRISM,
  formulas are represented as single identifiers, and thus can be substituted
  without increasing the size of the source code.  To prove this correct, we
  would have to keep an additional map with all the formulas generated by
  inlining, which would introduce a stateful invariant that would complicate the
  proof.  For simplicity, the Coq code avoids formulas and inlines assignments
  via substitution.  Textually, the Haskell code calls an `intern` function to
  allocate these formulas, whereas the Coq code does not need the interning.
